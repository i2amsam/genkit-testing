import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-DFMI36TU.mjs";
import {
  Message,
  tagAsPreamble
} from "@genkit-ai/ai";
import { AsyncLocalStorage } from "node:async_hooks";
import { v4 as uuidv4 } from "uuid";
import { Chat, MAIN_THREAD } from "./chat";
class Session {
  constructor(genkit, options) {
    this.genkit = genkit;
    var _a, _b, _c;
    this.id = (_a = options == null ? void 0 : options.id) != null ? _a : uuidv4();
    this.sessionData = (_b = options == null ? void 0 : options.sessionData) != null ? _b : {
      id: this.id
    };
    if (!this.sessionData) {
      this.sessionData = { id: this.id };
    }
    if (!this.sessionData.threads) {
      this.sessionData.threads = {};
    }
    this.store = (_c = options == null ? void 0 : options.store) != null ? _c : new InMemorySessionStore();
  }
  get state() {
    if (this.genkit instanceof Session) {
      return this.genkit.state;
    }
    return this.sessionData.state;
  }
  /**
   * Update session state data.
   */
  updateState(data) {
    return __async(this, null, function* () {
      let sessionData = this.sessionData;
      if (!sessionData) {
        sessionData = {};
      }
      sessionData.state = data;
      this.sessionData = sessionData;
      yield this.store.save(this.id, sessionData);
    });
  }
  /**
   * Update messages for a given thread.
   */
  updateMessages(thread, messasges) {
    return __async(this, null, function* () {
      let sessionData = this.sessionData;
      if (!sessionData) {
        sessionData = {};
      }
      if (!sessionData.threads) {
        sessionData.threads = {};
      }
      sessionData.threads[thread] = messasges;
      this.sessionData = sessionData;
      yield this.store.save(this.id, sessionData);
    });
  }
  chat(optionsOrThreadName, maybeOptions) {
    return runWithSession(this, () => {
      var _a, _b, _c, _d;
      let options;
      let threadName = MAIN_THREAD;
      if (maybeOptions) {
        threadName = optionsOrThreadName;
        options = maybeOptions;
      } else if (optionsOrThreadName) {
        if (typeof optionsOrThreadName === "string") {
          threadName = optionsOrThreadName;
        } else {
          options = optionsOrThreadName;
        }
      }
      let requestBase;
      if (!!((_a = options == null ? void 0 : options.prompt) == null ? void 0 : _a.render)) {
        const renderOptions = options;
        requestBase = renderOptions.prompt.render({
          input: renderOptions.input
        }).then((rb) => {
          return __spreadProps(__spreadValues({}, rb), {
            messages: tagAsPreamble(rb == null ? void 0 : rb.messages)
          });
        });
      } else {
        const baseOptions = __spreadValues({}, options);
        const messages = [];
        if (baseOptions.system) {
          messages.push({
            role: "system",
            content: Message.parseContent(baseOptions.system)
          });
        }
        delete baseOptions.system;
        if (baseOptions.messages) {
          messages.push(...baseOptions.messages);
        }
        baseOptions.messages = tagAsPreamble(messages);
        requestBase = Promise.resolve(baseOptions);
      }
      return new Chat(this, requestBase, {
        thread: threadName,
        id: this.id,
        messages: (_d = ((_b = this.sessionData) == null ? void 0 : _b.threads) && ((_c = this.sessionData) == null ? void 0 : _c.threads[threadName])) != null ? _d : []
      });
    });
  }
  /**
   * Executes provided function within this session context allowing calling
   * `ai.currentSession().state`
   */
  run(fn) {
    return runWithSession(this, fn);
  }
  toJSON() {
    return this.sessionData;
  }
}
const sessionAls = new AsyncLocalStorage();
function runWithSession(session, fn) {
  return sessionAls.run(session, fn);
}
function getCurrentSession() {
  return sessionAls.getStore();
}
class SessionError extends Error {
  constructor(msg) {
    super(msg);
  }
}
function inMemorySessionStore() {
  return new InMemorySessionStore();
}
class InMemorySessionStore {
  constructor() {
    this.data = {};
  }
  get(sessionId) {
    return __async(this, null, function* () {
      return this.data[sessionId];
    });
  }
  save(sessionId, sessionData) {
    return __async(this, null, function* () {
      this.data[sessionId] = sessionData;
    });
  }
}
export {
  Session,
  SessionError,
  getCurrentSession,
  inMemorySessionStore,
  runWithSession
};
//# sourceMappingURL=session.mjs.map