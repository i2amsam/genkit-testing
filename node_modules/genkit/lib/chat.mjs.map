{"version":3,"sources":["../src/chat.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ExecutablePrompt,\n  GenerateOptions,\n  GenerateResponse,\n  GenerateStreamOptions,\n  GenerateStreamResponse,\n  GenerationCommonConfigSchema,\n  MessageData,\n  Part,\n} from '@genkit-ai/ai';\nimport { z } from '@genkit-ai/core';\nimport { Genkit } from './genkit';\nimport {\n  BaseGenerateOptions,\n  Session,\n  SessionStore,\n  runWithSession,\n} from './session';\nimport { runInNewSpan } from './tracing';\n\nexport const MAIN_THREAD = 'main';\n\nexport type ChatGenerateOptions<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = z.ZodTypeAny,\n> = GenerateOptions<O, CustomOptions>;\n\nexport interface PromptRenderOptions<I> {\n  prompt: ExecutablePrompt<I>;\n  input?: I;\n}\n\nexport type ChatOptions<I = undefined, S = any> = (\n  | PromptRenderOptions<I>\n  | BaseGenerateOptions\n) & {\n  store?: SessionStore<S>;\n  sessionId?: string;\n};\n\n/**\n * Chat encapsulates a statful execution environment for chat.\n * Chat session executed within a session in this environment will have acesss to\n * session convesation history.\n *\n * ```ts\n * const ai = genkit({...});\n * const chat = ai.chat(); // create a Chat\n * let response = await chat.send('hi, my name is Genkit');\n * response = await chat.send('what is my name?'); // chat history aware conversation\n * ```\n */\nexport class Chat {\n  private requestBase?: Promise<BaseGenerateOptions>;\n  readonly sessionId: string;\n  private _messages?: MessageData[];\n  private threadName: string;\n\n  constructor(\n    readonly session: Session,\n    requestBase: Promise<BaseGenerateOptions>,\n    options: {\n      id: string;\n      thread: string;\n      messages?: MessageData[];\n    }\n  ) {\n    this.sessionId = options.id;\n    this.threadName = options.thread;\n    this.requestBase = requestBase?.then((rb) => {\n      const requestBase = { ...rb };\n      // this is handling dotprompt render case\n      if (requestBase && requestBase['prompt']) {\n        const basePrompt = requestBase['prompt'] as string | Part | Part[];\n        let promptMessage: MessageData;\n        if (typeof basePrompt === 'string') {\n          promptMessage = {\n            role: 'user',\n            content: [{ text: basePrompt }],\n          };\n        } else if (Array.isArray(basePrompt)) {\n          promptMessage = {\n            role: 'user',\n            content: basePrompt,\n          };\n        } else {\n          promptMessage = {\n            role: 'user',\n            content: [basePrompt],\n          };\n        }\n        requestBase.messages = [...(requestBase.messages ?? []), promptMessage];\n      }\n      requestBase.messages = [\n        ...(options.messages ?? []),\n        ...(requestBase.messages ?? []),\n      ];\n      this._messages = requestBase.messages;\n      return requestBase;\n    });\n    this._messages = options.messages;\n  }\n\n  async send<\n    O extends z.ZodTypeAny = z.ZodTypeAny,\n    CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema,\n  >(\n    options: string | Part[] | ChatGenerateOptions<O, CustomOptions>\n  ): Promise<GenerateResponse<z.infer<O>>> {\n    return runWithSession(this.session, () =>\n      runInNewSpan({ metadata: { name: 'send' } }, async () => {\n        let resolvedOptions;\n        let streamingCallback = undefined;\n\n        // string\n        if (typeof options === 'string') {\n          resolvedOptions = {\n            prompt: options,\n          } as ChatGenerateOptions<O, CustomOptions>;\n        } else if (Array.isArray(options)) {\n          // Part[]\n          resolvedOptions = {\n            prompt: options,\n          } as ChatGenerateOptions<O, CustomOptions>;\n        } else {\n          resolvedOptions = options as ChatGenerateOptions<O, CustomOptions>;\n          streamingCallback = resolvedOptions.streamingCallback;\n        }\n        let request: GenerateOptions = {\n          ...(await this.requestBase),\n          messages: this.messages,\n          ...resolvedOptions,\n        };\n        let response = await this.genkit.generate({\n          ...request,\n          streamingCallback,\n        });\n        this.requestBase = Promise.resolve({\n          ...(await this.requestBase),\n          // these things may get changed by tools calling within generate.\n          tools: response?.request?.tools,\n          config: response?.request?.config,\n        });\n        await this.updateMessages(response.messages);\n        return response;\n      })\n    );\n  }\n\n  sendStream<\n    O extends z.ZodTypeAny = z.ZodTypeAny,\n    CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema,\n  >(\n    options: string | Part[] | GenerateStreamOptions<O, CustomOptions>\n  ): Promise<GenerateStreamResponse<z.infer<O>>> {\n    return runWithSession(this.session, () =>\n      runInNewSpan({ metadata: { name: 'send' } }, async () => {\n        let resolvedOptions;\n\n        // string\n        if (typeof options === 'string') {\n          resolvedOptions = {\n            prompt: options,\n          } as GenerateStreamOptions<O, CustomOptions>;\n        } else if (Array.isArray(options)) {\n          // Part[]\n          resolvedOptions = {\n            prompt: options,\n          } as GenerateStreamOptions<O, CustomOptions>;\n        } else {\n          resolvedOptions = options as GenerateStreamOptions<O, CustomOptions>;\n        }\n\n        const { response, stream } = await this.genkit.generateStream({\n          ...(await this.requestBase),\n          messages: this.messages,\n          ...resolvedOptions,\n        });\n\n        return {\n          response: response.finally(async () => {\n            const resolvedResponse = await response;\n            this.requestBase = Promise.resolve({\n              ...(await this.requestBase),\n              // these things may get changed by tools calling within generate.\n              tools: resolvedResponse?.request?.tools,\n              config: resolvedResponse?.request?.config,\n            });\n            this.updateMessages(resolvedResponse.messages);\n          }),\n          stream,\n        };\n      })\n    );\n  }\n\n  private get genkit(): Genkit {\n    return this.session.genkit;\n  }\n\n  get messages(): MessageData[] {\n    return this._messages ?? [];\n  }\n\n  async updateMessages(messages: MessageData[]): Promise<void> {\n    this._messages = messages;\n    await this.session.updateMessages(this.threadName, messages);\n  }\n}\n"],"mappings":";;;;;AA4BA;AAAA,EAIE;AAAA,OACK;AACP,SAAS,oBAAoB;AAEtB,MAAM,cAAc;AAgCpB,MAAM,KAAK;AAAA,EAMhB,YACW,SACT,aACA,SAKA;AAPS;AAQT,SAAK,YAAY,QAAQ;AACzB,SAAK,aAAa,QAAQ;AAC1B,SAAK,cAAc,2CAAa,KAAK,CAAC,OAAO;AArFjD;AAsFM,YAAMA,eAAc,mBAAK;AAEzB,UAAIA,gBAAeA,aAAY,QAAQ,GAAG;AACxC,cAAM,aAAaA,aAAY,QAAQ;AACvC,YAAI;AACJ,YAAI,OAAO,eAAe,UAAU;AAClC,0BAAgB;AAAA,YACd,MAAM;AAAA,YACN,SAAS,CAAC,EAAE,MAAM,WAAW,CAAC;AAAA,UAChC;AAAA,QACF,WAAW,MAAM,QAAQ,UAAU,GAAG;AACpC,0BAAgB;AAAA,YACd,MAAM;AAAA,YACN,SAAS;AAAA,UACX;AAAA,QACF,OAAO;AACL,0BAAgB;AAAA,YACd,MAAM;AAAA,YACN,SAAS,CAAC,UAAU;AAAA,UACtB;AAAA,QACF;AACA,QAAAA,aAAY,WAAW,CAAC,IAAI,KAAAA,aAAY,aAAZ,YAAwB,CAAC,GAAI,aAAa;AAAA,MACxE;AACA,MAAAA,aAAY,WAAW;AAAA,QACrB,IAAI,aAAQ,aAAR,YAAoB,CAAC;AAAA,QACzB,IAAI,KAAAA,aAAY,aAAZ,YAAwB,CAAC;AAAA,MAC/B;AACA,WAAK,YAAYA,aAAY;AAC7B,aAAOA;AAAA,IACT;AACA,SAAK,YAAY,QAAQ;AAAA,EAC3B;AAAA,EAEM,KAIJ,SACuC;AAAA;AACvC,aAAO;AAAA,QAAe,KAAK;AAAA,QAAS,MAClC,aAAa,EAAE,UAAU,EAAE,MAAM,OAAO,EAAE,GAAG,MAAY;AA9H/D;AA+HQ,cAAI;AACJ,cAAI,oBAAoB;AAGxB,cAAI,OAAO,YAAY,UAAU;AAC/B,8BAAkB;AAAA,cAChB,QAAQ;AAAA,YACV;AAAA,UACF,WAAW,MAAM,QAAQ,OAAO,GAAG;AAEjC,8BAAkB;AAAA,cAChB,QAAQ;AAAA,YACV;AAAA,UACF,OAAO;AACL,8BAAkB;AAClB,gCAAoB,gBAAgB;AAAA,UACtC;AACA,cAAI,UAA2B,gDACzB,MAAM,KAAK,cADc;AAAA,YAE7B,UAAU,KAAK;AAAA,cACZ;AAEL,cAAI,WAAW,MAAM,KAAK,OAAO,SAAS,iCACrC,UADqC;AAAA,YAExC;AAAA,UACF,EAAC;AACD,eAAK,cAAc,QAAQ,QAAQ,iCAC7B,MAAM,KAAK,cADkB;AAAA;AAAA,YAGjC,QAAO,0CAAU,YAAV,mBAAmB;AAAA,YAC1B,SAAQ,0CAAU,YAAV,mBAAmB;AAAA,UAC7B,EAAC;AACD,gBAAM,KAAK,eAAe,SAAS,QAAQ;AAC3C,iBAAO;AAAA,QACT,EAAC;AAAA,MACH;AAAA,IACF;AAAA;AAAA,EAEA,WAIE,SAC6C;AAC7C,WAAO;AAAA,MAAe,KAAK;AAAA,MAAS,MAClC,aAAa,EAAE,UAAU,EAAE,MAAM,OAAO,EAAE,GAAG,MAAY;AACvD,YAAI;AAGJ,YAAI,OAAO,YAAY,UAAU;AAC/B,4BAAkB;AAAA,YAChB,QAAQ;AAAA,UACV;AAAA,QACF,WAAW,MAAM,QAAQ,OAAO,GAAG;AAEjC,4BAAkB;AAAA,YAChB,QAAQ;AAAA,UACV;AAAA,QACF,OAAO;AACL,4BAAkB;AAAA,QACpB;AAEA,cAAM,EAAE,UAAU,OAAO,IAAI,MAAM,KAAK,OAAO,eAAe,gDACxD,MAAM,KAAK,cAD6C;AAAA,UAE5D,UAAU,KAAK;AAAA,YACZ,gBACJ;AAED,eAAO;AAAA,UACL,UAAU,SAAS,QAAQ,MAAY;AApMjD;AAqMY,kBAAM,mBAAmB,MAAM;AAC/B,iBAAK,cAAc,QAAQ,QAAQ,iCAC7B,MAAM,KAAK,cADkB;AAAA;AAAA,cAGjC,QAAO,0DAAkB,YAAlB,mBAA2B;AAAA,cAClC,SAAQ,0DAAkB,YAAlB,mBAA2B;AAAA,YACrC,EAAC;AACD,iBAAK,eAAe,iBAAiB,QAAQ;AAAA,UAC/C,EAAC;AAAA,UACD;AAAA,QACF;AAAA,MACF,EAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,IAAY,SAAiB;AAC3B,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA,EAEA,IAAI,WAA0B;AAxNhC;AAyNI,YAAO,UAAK,cAAL,YAAkB,CAAC;AAAA,EAC5B;AAAA,EAEM,eAAe,UAAwC;AAAA;AAC3D,WAAK,YAAY;AACjB,YAAM,KAAK,QAAQ,eAAe,KAAK,YAAY,QAAQ;AAAA,IAC7D;AAAA;AACF;","names":["requestBase"]}