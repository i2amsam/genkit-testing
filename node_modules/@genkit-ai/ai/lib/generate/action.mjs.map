{"version":3,"sources":["../../src/generate/action.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getStreamingCallback,\n  Middleware,\n  runWithStreamingCallback,\n  z,\n} from '@genkit-ai/core';\nimport { Registry } from '@genkit-ai/core/registry';\nimport { toJsonSchema } from '@genkit-ai/core/schema';\nimport { runInNewSpan, SPAN_TYPE_ATTR } from '@genkit-ai/core/tracing';\nimport * as clc from 'colorette';\nimport { DocumentDataSchema } from '../document.js';\nimport {\n  GenerateResponse,\n  GenerateResponseChunk,\n  tagAsPreamble,\n} from '../generate.js';\nimport {\n  GenerateRequest,\n  GenerateRequestSchema,\n  GenerateResponseChunkData,\n  GenerateResponseData,\n  MessageData,\n  MessageSchema,\n  ModelAction,\n  Part,\n  Role,\n  ToolDefinitionSchema,\n  ToolResponsePart,\n} from '../model.js';\nimport { lookupToolByName, ToolAction, toToolDefinition } from '../tool.js';\n\nexport const GenerateUtilParamSchema = z.object({\n  /** A model name (e.g. `vertexai/gemini-1.0-pro`). */\n  model: z.string(),\n  /** Retrieved documents to be used as context for this generation. */\n  docs: z.array(DocumentDataSchema).optional(),\n  /** Conversation history for multi-turn prompting when supported by the underlying model. */\n  messages: z.array(MessageSchema),\n  /** List of registered tool names for this generation if supported by the underlying model. */\n  tools: z.array(z.union([z.string(), ToolDefinitionSchema])).optional(),\n  /** Configuration for the generation request. */\n  config: z.any().optional(),\n  /** Configuration for the desired output of the request. Defaults to the model's default output if unspecified. */\n  output: z\n    .object({\n      format: z\n        .union([z.literal('text'), z.literal('json'), z.literal('media')])\n        .optional(),\n      jsonSchema: z.any().optional(),\n    })\n    .optional(),\n  /** When true, return tool calls for manual processing instead of automatically resolving them. */\n  returnToolRequests: z.boolean().optional(),\n});\n\n/**\n * Encapsulates all generate logic. This is similar to `generateAction` except not an action and can take middleware.\n */\nexport async function generateHelper(\n  registry: Registry,\n  input: z.infer<typeof GenerateUtilParamSchema>,\n  middleware?: Middleware[]\n): Promise<GenerateResponseData> {\n  // do tracing\n  return await runInNewSpan(\n    {\n      metadata: {\n        name: 'generate',\n      },\n      labels: {\n        [SPAN_TYPE_ATTR]: 'helper',\n      },\n    },\n    async (metadata) => {\n      metadata.name = 'generate';\n      metadata.input = input;\n      const output = await generate(registry, input, middleware);\n      metadata.output = JSON.stringify(output);\n      return output;\n    }\n  );\n}\n\nasync function generate(\n  registry: Registry,\n  rawRequest: z.infer<typeof GenerateUtilParamSchema>,\n  middleware?: Middleware[]\n): Promise<GenerateResponseData> {\n  const model = (await registry.lookupAction(\n    `/model/${rawRequest.model}`\n  )) as ModelAction;\n  if (!model) {\n    throw new Error(`Model ${rawRequest.model} not found`);\n  }\n  if (model.__action.metadata?.model.stage === 'deprecated') {\n    console.warn(\n      `${clc.bold(clc.yellow('Warning:'))} ` +\n        `Model '${model.__action.name}' is deprecated and may be removed in a future release.`\n    );\n  }\n\n  let tools: ToolAction[] | undefined;\n  if (rawRequest.tools?.length) {\n    if (!model.__action.metadata?.model.supports?.tools) {\n      throw new Error(\n        `Model ${rawRequest.model} does not support tools, but some tools were supplied to generate(). Please call generate() without tools if you would like to use this model.`\n      );\n    }\n    tools = await Promise.all(\n      rawRequest.tools.map(async (toolRef) => {\n        if (typeof toolRef === 'string') {\n          return lookupToolByName(registry, toolRef as string);\n        } else if (toolRef.name) {\n          return lookupToolByName(registry, toolRef.name);\n        }\n        throw `Unable to resolve tool ${JSON.stringify(toolRef)}`;\n      })\n    );\n  }\n  const request = await actionToGenerateRequest(rawRequest, tools);\n\n  const accumulatedChunks: GenerateResponseChunkData[] = [];\n\n  const streamingCallback = getStreamingCallback();\n  const response = await runWithStreamingCallback(\n    streamingCallback\n      ? (chunk: GenerateResponseChunkData) => {\n          // Store accumulated chunk data\n          if (streamingCallback) {\n            streamingCallback!(\n              new GenerateResponseChunk(chunk, {\n                previousChunks: accumulatedChunks,\n              })\n            );\n          }\n          accumulatedChunks.push(chunk);\n        }\n      : undefined,\n    async () => {\n      const dispatch = async (\n        index: number,\n        req: z.infer<typeof GenerateRequestSchema>\n      ) => {\n        if (!middleware || index === middleware.length) {\n          // end of the chain, call the original model action\n          return await model(req);\n        }\n\n        const currentMiddleware = middleware[index];\n        return currentMiddleware(req, async (modifiedReq) =>\n          dispatch(index + 1, modifiedReq || req)\n        );\n      };\n\n      return new GenerateResponse(await dispatch(0, request), request);\n    }\n  );\n\n  // Throw an error if the response is not usable.\n  response.assertValid(request);\n  const message = response.message!; // would have thrown if no message\n\n  const toolCalls = message.content.filter((part) => !!part.toolRequest);\n  if (rawRequest.returnToolRequests || toolCalls.length === 0) {\n    return response.toJSON();\n  }\n  const toolResponses: ToolResponsePart[] = [];\n  let messages: MessageData[] = [...request.messages, message];\n  let newTools = rawRequest.tools;\n  for (const part of toolCalls) {\n    if (!part.toolRequest) {\n      throw Error(\n        'Tool request expected but not provided in tool request part'\n      );\n    }\n    const tool = tools?.find(\n      (tool) => tool.__action.name === part.toolRequest?.name\n    );\n    if (!tool) {\n      throw Error(`Tool ${part.toolRequest?.name} not found`);\n    }\n    if ((tool.__action.metadata.type as string) === 'prompt') {\n      const newPreamble = await tool(part.toolRequest?.input);\n      toolResponses.push({\n        toolResponse: {\n          name: part.toolRequest.name,\n          ref: part.toolRequest.ref,\n          output: `transferred to ${part.toolRequest.name}`,\n        },\n      });\n      // swap out the preamble\n      messages = [\n        ...tagAsPreamble(newPreamble.messages)!,\n        ...messages.filter((m) => !m?.metadata?.preamble),\n      ];\n      newTools = newPreamble.tools;\n    } else {\n      toolResponses.push({\n        toolResponse: {\n          name: part.toolRequest.name,\n          ref: part.toolRequest.ref,\n          output: await tool(part.toolRequest?.input),\n        },\n      });\n    }\n  }\n  const nextRequest = {\n    ...rawRequest,\n    messages: [\n      ...messages,\n      {\n        role: 'tool',\n        content: toolResponses,\n      },\n    ] as MessageData[],\n    tools: newTools,\n  };\n  return await generateHelper(registry, nextRequest, middleware);\n}\n\nasync function actionToGenerateRequest(\n  options: z.infer<typeof GenerateUtilParamSchema>,\n  resolvedTools?: ToolAction[]\n): Promise<GenerateRequest> {\n  const out = {\n    messages: options.messages,\n    config: options.config,\n    docs: options.docs,\n    tools: resolvedTools?.map((tool) => toToolDefinition(tool)) || [],\n    output: {\n      format:\n        options.output?.format ||\n        (options.output?.jsonSchema ? 'json' : 'text'),\n      schema: toJsonSchema({\n        jsonSchema: options.output?.jsonSchema,\n      }),\n    },\n  };\n  if (!out.output.schema) delete out.output.schema;\n  return out;\n}\n\nexport function inferRoleFromParts(parts: Part[]): Role {\n  const uniqueRoles = new Set<Role>();\n  for (const part of parts) {\n    const role = getRoleFromPart(part);\n    uniqueRoles.add(role);\n    if (uniqueRoles.size > 1) {\n      throw new Error('Contents contain mixed roles');\n    }\n  }\n  return Array.from(uniqueRoles)[0];\n}\n\nfunction getRoleFromPart(part: Part): Role {\n  if (part.toolRequest !== undefined) return 'model';\n  if (part.toolResponse !== undefined) return 'tool';\n  if (part.text !== undefined) return 'user';\n  if (part.media !== undefined) return 'user';\n  if (part.data !== undefined) return 'user';\n  throw new Error('No recognized fields in content');\n}\n"],"mappings":"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","names":["tool","_a"]}