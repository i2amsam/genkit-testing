"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var generate_exports = {};
__export(generate_exports, {
  GenerateResponse: () => import_response.GenerateResponse,
  GenerateResponseChunk: () => import_chunk.GenerateResponseChunk,
  GenerationBlockedError: () => GenerationBlockedError,
  GenerationResponseError: () => GenerationResponseError,
  generate: () => generate,
  generateStream: () => generateStream,
  tagAsPreamble: () => tagAsPreamble,
  toGenerateRequest: () => toGenerateRequest
});
module.exports = __toCommonJS(generate_exports);
var import_core = require("@genkit-ai/core");
var import_schema = require("@genkit-ai/core/schema");
var import_action = require("./generate/action.js");
var import_chunk = require("./generate/chunk.js");
var import_response = require("./generate/response.js");
var import_message = require("./message.js");
var import_tool = require("./tool.js");
function toGenerateRequest(registry, options) {
  return __async(this, null, function* () {
    var _a, _b, _c, _d, _e;
    const messages = [];
    if (options.system) {
      messages.push({
        role: "system",
        content: import_message.Message.parseContent(options.system)
      });
    }
    if (options.messages) {
      messages.push(...options.messages.map((m) => import_message.Message.parseData(m)));
    }
    if (options.prompt) {
      messages.push({
        role: "user",
        content: import_message.Message.parseContent(options.prompt)
      });
    }
    if (messages.length === 0) {
      throw new Error("at least one message is required in generate request");
    }
    let tools;
    if (options.tools) {
      tools = yield (0, import_tool.resolveTools)(registry, options.tools);
    }
    const out = {
      messages,
      config: options.config,
      docs: options.docs,
      tools: (tools == null ? void 0 : tools.map((tool) => (0, import_tool.toToolDefinition)(tool))) || [],
      output: {
        format: ((_a = options.output) == null ? void 0 : _a.format) || (((_b = options.output) == null ? void 0 : _b.schema) || ((_c = options.output) == null ? void 0 : _c.jsonSchema) ? "json" : "text"),
        schema: (0, import_schema.toJsonSchema)({
          schema: (_d = options.output) == null ? void 0 : _d.schema,
          jsonSchema: (_e = options.output) == null ? void 0 : _e.jsonSchema
        })
      }
    };
    if (!out.output.schema) delete out.output.schema;
    return out;
  });
}
function resolveModel(registry, options) {
  return __async(this, null, function* () {
    let model = options.model;
    if (!model) {
      throw new Error("Model is required.");
    }
    if (typeof model === "string") {
      return {
        modelAction: yield registry.lookupAction(
          `/model/${model}`
        )
      };
    } else if (model.hasOwnProperty("__action")) {
      return { modelAction: model };
    } else {
      const ref = model;
      return {
        modelAction: yield registry.lookupAction(
          `/model/${ref.name}`
        ),
        config: __spreadValues({}, ref.config),
        version: ref.version
      };
    }
  });
}
class GenerationResponseError extends import_core.GenkitError {
  constructor(response, message, status, detail) {
    super({
      status: status || "FAILED_PRECONDITION",
      message
    });
    this.detail = __spreadValues({ response }, detail);
  }
}
class GenerationBlockedError extends GenerationResponseError {
}
function generate(registry, options) {
  return __async(this, null, function* () {
    var _a, _b, _c;
    const resolvedOptions = yield Promise.resolve(options);
    const resolvedModel = yield resolveModel(registry, resolvedOptions);
    const model = resolvedModel.modelAction;
    if (!model) {
      let modelId;
      if (typeof resolvedOptions.model === "string") {
        modelId = resolvedOptions.model;
      } else if ((_b = (_a = resolvedOptions.model) == null ? void 0 : _a.__action) == null ? void 0 : _b.name) {
        modelId = resolvedOptions.model.__action.name;
      } else {
        modelId = resolvedOptions.model.name;
      }
      throw new Error(`Model ${modelId} not found`);
    }
    let tools;
    if (resolvedOptions.tools) {
      tools = [];
      for (const t of resolvedOptions.tools) {
        if (typeof t === "string") {
          tools.push(yield resolveFullToolName(registry, t));
        } else if (t.__action) {
          tools.push(
            `/${(_c = t.__action.metadata) == null ? void 0 : _c.type}/${t.__action.name}`
          );
        } else if (typeof t.asTool === "function") {
          const promptToolAction = t.asTool();
          tools.push(`/prompt/${promptToolAction.__action.name}`);
        } else if (t.name) {
          tools.push(yield resolveFullToolName(registry, t.name));
        } else {
          throw new Error(
            `Unable to determine type of of tool: ${JSON.stringify(t)}`
          );
        }
      }
    }
    const messages = [];
    if (resolvedOptions.system) {
      messages.push({
        role: "system",
        content: import_message.Message.parseContent(resolvedOptions.system)
      });
    }
    if (resolvedOptions.messages) {
      messages.push(...resolvedOptions.messages);
    }
    if (resolvedOptions.prompt) {
      messages.push({
        role: "user",
        content: import_message.Message.parseContent(resolvedOptions.prompt)
      });
    }
    if (messages.length === 0) {
      throw new Error("at least one message is required in generate request");
    }
    const params = {
      model: model.__action.name,
      docs: resolvedOptions.docs,
      messages,
      tools,
      config: __spreadValues(__spreadValues({
        version: resolvedModel.version
      }, stripUndefinedOptions(resolvedModel.config)), stripUndefinedOptions(resolvedOptions.config)),
      output: resolvedOptions.output && {
        format: resolvedOptions.output.format,
        jsonSchema: resolvedOptions.output.schema ? (0, import_schema.toJsonSchema)({
          schema: resolvedOptions.output.schema,
          jsonSchema: resolvedOptions.output.jsonSchema
        }) : resolvedOptions.output.jsonSchema
      },
      returnToolRequests: resolvedOptions.returnToolRequests
    };
    return yield (0, import_core.runWithStreamingCallback)(
      resolvedOptions.streamingCallback,
      () => __async(this, null, function* () {
        var _a2;
        const response = yield (0, import_action.generateHelper)(
          registry,
          params,
          resolvedOptions.use
        );
        return new import_response.GenerateResponse(
          response,
          (_a2 = response.request) != null ? _a2 : yield toGenerateRequest(registry, __spreadProps(__spreadValues({}, resolvedOptions), { tools }))
        );
      })
    );
  });
}
function stripUndefinedOptions(input) {
  if (!input) return input;
  const copy = __spreadValues({}, input);
  Object.keys(input).forEach((key) => {
    if (copy[key] === void 0) {
      delete copy[key];
    }
  });
  return copy;
}
function resolveFullToolName(registry, name) {
  return __async(this, null, function* () {
    if (yield registry.lookupAction(`/tool/${name}`)) {
      return `/tool/${name}`;
    } else if (yield registry.lookupAction(`/prompt/${name}`)) {
      return `/prompt/${name}`;
    } else {
      throw new Error(`Unable to determine type of of tool: ${name}`);
    }
  });
}
function createPromise() {
  let resolve, reject;
  let promise = new Promise((res, rej) => [resolve, reject] = [res, rej]);
  return { resolve, reject, promise };
}
function generateStream(registry, options) {
  return __async(this, null, function* () {
    let firstChunkSent = false;
    return new Promise(
      (initialResolve, initialReject) => {
        const {
          resolve: finalResolve,
          reject: finalReject,
          promise: finalPromise
        } = createPromise();
        let provideNextChunk, nextChunk;
        ({ resolve: provideNextChunk, promise: nextChunk } = createPromise());
        function chunkStream() {
          return __asyncGenerator(this, null, function* () {
            while (true) {
              const next = yield new __await(nextChunk);
              if (!next) break;
              yield next;
            }
          });
        }
        try {
          generate(registry, __spreadProps(__spreadValues({}, options), {
            streamingCallback: (chunk) => {
              firstChunkSent = true;
              provideNextChunk(chunk);
              ({ resolve: provideNextChunk, promise: nextChunk } = createPromise());
            }
          })).then((result) => {
            provideNextChunk(null);
            finalResolve(result);
          });
        } catch (e) {
          if (!firstChunkSent) {
            initialReject(e);
            return;
          }
          provideNextChunk(null);
          finalReject(e);
        }
        initialResolve({
          get response() {
            return finalPromise;
          },
          get stream() {
            return chunkStream();
          }
        });
      }
    );
  });
}
function tagAsPreamble(msgs) {
  if (!msgs) {
    return void 0;
  }
  return msgs.map((m) => __spreadProps(__spreadValues({}, m), {
    metadata: __spreadProps(__spreadValues({}, m.metadata), {
      preamble: true
    })
  }));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GenerateResponse,
  GenerateResponseChunk,
  GenerationBlockedError,
  GenerationResponseError,
  generate,
  generateStream,
  tagAsPreamble,
  toGenerateRequest
});
//# sourceMappingURL=generate.js.map