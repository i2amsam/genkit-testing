import {
  __async,
  __asyncGenerator,
  __await,
  __spreadProps,
  __spreadValues
} from "./chunk-7LUMLJGI.mjs";
import {
  GenkitError,
  runWithStreamingCallback
} from "@genkit-ai/core";
import { toJsonSchema } from "@genkit-ai/core/schema";
import { generateHelper } from "./generate/action.js";
import { GenerateResponseChunk } from "./generate/chunk.js";
import { GenerateResponse } from "./generate/response.js";
import { Message } from "./message.js";
import { resolveTools, toToolDefinition } from "./tool.js";
function toGenerateRequest(registry, options) {
  return __async(this, null, function* () {
    var _a, _b, _c, _d, _e;
    const messages = [];
    if (options.system) {
      messages.push({
        role: "system",
        content: Message.parseContent(options.system)
      });
    }
    if (options.messages) {
      messages.push(...options.messages.map((m) => Message.parseData(m)));
    }
    if (options.prompt) {
      messages.push({
        role: "user",
        content: Message.parseContent(options.prompt)
      });
    }
    if (messages.length === 0) {
      throw new Error("at least one message is required in generate request");
    }
    let tools;
    if (options.tools) {
      tools = yield resolveTools(registry, options.tools);
    }
    const out = {
      messages,
      config: options.config,
      docs: options.docs,
      tools: (tools == null ? void 0 : tools.map((tool) => toToolDefinition(tool))) || [],
      output: {
        format: ((_a = options.output) == null ? void 0 : _a.format) || (((_b = options.output) == null ? void 0 : _b.schema) || ((_c = options.output) == null ? void 0 : _c.jsonSchema) ? "json" : "text"),
        schema: toJsonSchema({
          schema: (_d = options.output) == null ? void 0 : _d.schema,
          jsonSchema: (_e = options.output) == null ? void 0 : _e.jsonSchema
        })
      }
    };
    if (!out.output.schema) delete out.output.schema;
    return out;
  });
}
function resolveModel(registry, options) {
  return __async(this, null, function* () {
    let model = options.model;
    if (!model) {
      throw new Error("Model is required.");
    }
    if (typeof model === "string") {
      return {
        modelAction: yield registry.lookupAction(
          `/model/${model}`
        )
      };
    } else if (model.hasOwnProperty("__action")) {
      return { modelAction: model };
    } else {
      const ref = model;
      return {
        modelAction: yield registry.lookupAction(
          `/model/${ref.name}`
        ),
        config: __spreadValues({}, ref.config),
        version: ref.version
      };
    }
  });
}
class GenerationResponseError extends GenkitError {
  constructor(response, message, status, detail) {
    super({
      status: status || "FAILED_PRECONDITION",
      message
    });
    this.detail = __spreadValues({ response }, detail);
  }
}
class GenerationBlockedError extends GenerationResponseError {
}
function generate(registry, options) {
  return __async(this, null, function* () {
    var _a, _b, _c;
    const resolvedOptions = yield Promise.resolve(options);
    const resolvedModel = yield resolveModel(registry, resolvedOptions);
    const model = resolvedModel.modelAction;
    if (!model) {
      let modelId;
      if (typeof resolvedOptions.model === "string") {
        modelId = resolvedOptions.model;
      } else if ((_b = (_a = resolvedOptions.model) == null ? void 0 : _a.__action) == null ? void 0 : _b.name) {
        modelId = resolvedOptions.model.__action.name;
      } else {
        modelId = resolvedOptions.model.name;
      }
      throw new Error(`Model ${modelId} not found`);
    }
    let tools;
    if (resolvedOptions.tools) {
      tools = [];
      for (const t of resolvedOptions.tools) {
        if (typeof t === "string") {
          tools.push(yield resolveFullToolName(registry, t));
        } else if (t.__action) {
          tools.push(
            `/${(_c = t.__action.metadata) == null ? void 0 : _c.type}/${t.__action.name}`
          );
        } else if (typeof t.asTool === "function") {
          const promptToolAction = t.asTool();
          tools.push(`/prompt/${promptToolAction.__action.name}`);
        } else if (t.name) {
          tools.push(yield resolveFullToolName(registry, t.name));
        } else {
          throw new Error(
            `Unable to determine type of of tool: ${JSON.stringify(t)}`
          );
        }
      }
    }
    const messages = [];
    if (resolvedOptions.system) {
      messages.push({
        role: "system",
        content: Message.parseContent(resolvedOptions.system)
      });
    }
    if (resolvedOptions.messages) {
      messages.push(...resolvedOptions.messages);
    }
    if (resolvedOptions.prompt) {
      messages.push({
        role: "user",
        content: Message.parseContent(resolvedOptions.prompt)
      });
    }
    if (messages.length === 0) {
      throw new Error("at least one message is required in generate request");
    }
    const params = {
      model: model.__action.name,
      docs: resolvedOptions.docs,
      messages,
      tools,
      config: __spreadValues(__spreadValues({
        version: resolvedModel.version
      }, stripUndefinedOptions(resolvedModel.config)), stripUndefinedOptions(resolvedOptions.config)),
      output: resolvedOptions.output && {
        format: resolvedOptions.output.format,
        jsonSchema: resolvedOptions.output.schema ? toJsonSchema({
          schema: resolvedOptions.output.schema,
          jsonSchema: resolvedOptions.output.jsonSchema
        }) : resolvedOptions.output.jsonSchema
      },
      returnToolRequests: resolvedOptions.returnToolRequests
    };
    return yield runWithStreamingCallback(
      resolvedOptions.streamingCallback,
      () => __async(this, null, function* () {
        var _a2;
        const response = yield generateHelper(
          registry,
          params,
          resolvedOptions.use
        );
        return new GenerateResponse(
          response,
          (_a2 = response.request) != null ? _a2 : yield toGenerateRequest(registry, __spreadProps(__spreadValues({}, resolvedOptions), { tools }))
        );
      })
    );
  });
}
function stripUndefinedOptions(input) {
  if (!input) return input;
  const copy = __spreadValues({}, input);
  Object.keys(input).forEach((key) => {
    if (copy[key] === void 0) {
      delete copy[key];
    }
  });
  return copy;
}
function resolveFullToolName(registry, name) {
  return __async(this, null, function* () {
    if (yield registry.lookupAction(`/tool/${name}`)) {
      return `/tool/${name}`;
    } else if (yield registry.lookupAction(`/prompt/${name}`)) {
      return `/prompt/${name}`;
    } else {
      throw new Error(`Unable to determine type of of tool: ${name}`);
    }
  });
}
function createPromise() {
  let resolve, reject;
  let promise = new Promise((res, rej) => [resolve, reject] = [res, rej]);
  return { resolve, reject, promise };
}
function generateStream(registry, options) {
  return __async(this, null, function* () {
    let firstChunkSent = false;
    return new Promise(
      (initialResolve, initialReject) => {
        const {
          resolve: finalResolve,
          reject: finalReject,
          promise: finalPromise
        } = createPromise();
        let provideNextChunk, nextChunk;
        ({ resolve: provideNextChunk, promise: nextChunk } = createPromise());
        function chunkStream() {
          return __asyncGenerator(this, null, function* () {
            while (true) {
              const next = yield new __await(nextChunk);
              if (!next) break;
              yield next;
            }
          });
        }
        try {
          generate(registry, __spreadProps(__spreadValues({}, options), {
            streamingCallback: (chunk) => {
              firstChunkSent = true;
              provideNextChunk(chunk);
              ({ resolve: provideNextChunk, promise: nextChunk } = createPromise());
            }
          })).then((result) => {
            provideNextChunk(null);
            finalResolve(result);
          });
        } catch (e) {
          if (!firstChunkSent) {
            initialReject(e);
            return;
          }
          provideNextChunk(null);
          finalReject(e);
        }
        initialResolve({
          get response() {
            return finalPromise;
          },
          get stream() {
            return chunkStream();
          }
        });
      }
    );
  });
}
function tagAsPreamble(msgs) {
  if (!msgs) {
    return void 0;
  }
  return msgs.map((m) => __spreadProps(__spreadValues({}, m), {
    metadata: __spreadProps(__spreadValues({}, m.metadata), {
      preamble: true
    })
  }));
}
export {
  GenerateResponse,
  GenerateResponseChunk,
  GenerationBlockedError,
  GenerationResponseError,
  generate,
  generateStream,
  tagAsPreamble,
  toGenerateRequest
};
//# sourceMappingURL=generate.mjs.map